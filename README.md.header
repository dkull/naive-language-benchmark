# naive-language-benchmark

Comparing naive implementations in compiled languages. The goal is to compare the optimization capabilities of the compilers behind the languages.

All the benchmarks are written by me in good faith. I don't use any of these languages daily, though I have written something non-trivial in each of them at some point in time.
A new benchmark starts out as an implementation in one language. The following languages will try to mimic the structure of the original one as closely as possible. Getting the follow-up languages to run is mostly just satisfying the compiler errors and playing around with casts/types. Some testing of different integer types is done for performance.

Each language will get a custom set of compiler flags - no benchmark specific flags. Flags described in the compilers '--help' are priority and acceptable.

Compiler flags are chosen on the basis of "optimize everything - simply!". Usually something like '-release -Ofast -flto -march=native -boundscheck=off' is used. Some A/B testing is done when choosing the subset.

Required software in $PATH: rustc ; v ; zig ; gccgo ; gcc ; go ; dmd; screenfetch (optional for README.md)

Run for just the benchmark tables:
```
make -s benchmark_table
```

Run to generate this README.md:
```
make -s readme
```

